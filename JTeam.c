#pragma config(Sensor, dgtl1,  ,               sensorQuadEncoder)
#pragma config(Sensor, dgtl12, bluePin,        sensorDigitalIn)
#pragma config(Motor,  port2,           BLDrive,       tmotorVex393, openLoop)
#pragma config(Motor,  port3,           FLDrive,       tmotorVex393, openLoop)
#pragma config(Motor,  port4,           BRDrive,       tmotorVex393, openLoop)
#pragma config(Motor,  port5,           FRDrive,       tmotorVex393, openLoop, encoder, encoderPort, dgtl1, 1000)
#pragma config(Motor,  port6,           HDrive,        tmotorVex393, openLoop)
#pragma config(Motor,  port7,           RArm,          tmotorVex393, openLoop)
#pragma config(Motor,  port8,           LArm,          tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Vex_Competition_Includes.c"

// 127 Backwards
void drive(int left, int right, int horiz) {
	motor[FLDrive] = left;
	motor[BLDrive] = left;
	motor[FRDrive] = right;
	motor[BRDrive] = right;
	motor[HDrive] = horiz;
}

void arm(int left, int right) {
	motor[LArm] = left;
	motor[RArm] = right;
}

void pre_auton() {
	bStopTasksBetweenModes = true;
}

task autonomous() {
	bool blue = SensorValue[bluePin] ? false : true;
	int factor = blue ? -1 : 1;
	drive(0, 0, 127);
	wait1Msec(2000);
	nMotorEncoder[FRDrive] = 0;
	while (abs(nMotorEncoder[FRDrive]) < 1500) {
		drive(factor * 127, factor *127, 96);
	}
	drive(0, 0, 0);
	wait1Msec(500);
	arm(blue ? 0 : -127, blue ? -127 : 0);
	wait1Msec(500);
	arm(0, 0);
}

task usercontrol() {
	bool pressed = false;
	bool driveEnabled = true;
	while (true) {
		if (driveEnabled) {
			drive(vexRT[Ch3], vexRT[Ch2], vexRT[Ch1]);
		} else {
			arm(vexRT[Ch3], vexRT[Ch2]);
		}

		if (!pressed && vexRT[Btn8D]) driveEnabled = !driveEnabled;
		pressed = vexRT[Btn8D] ? true : false;
		wait1Msec(20);
	}
}
